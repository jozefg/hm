## An Explanation of This Code

OK, so now that I've wowed you with my awesome code, let's talk about
what's going on. Type inference breaks down into essentially 2
components

 1. Constraint Generation
 2. Unification

We inspect the program we're trying to infer a type for and generate a
bunch of statements (constraints) which are of the form

> This type is equal to this type

These types have "unification variables" in them. These **aren't
normal ML type variables**. They're generated by the compiler, for the
compiler, and will eventually be filled in with either

 1. A rigid polymorphic variable
 2. A normal concrete type

For example, if we're looking at the expression

``` sml
   f a
```

We first just say that `f : 'f` where `'f` is one of those unification
variables I mentioned. Next we say that `a : 'a`. Since we're apply
`f` to `a` we can generate the constraints that

    'f ~ 'x -> 'y
    'a ~ 'x

We then unify these constraints to produce `f : 'a -> 'x` and `a :
'a`. We'd then using the surrounding constraints to produce more
information about what exactly `'a` and `'x` might be.

Now onto some specifics

## Set Up

In order to actually talk about type inference we first have to define
our language. We have the abstract syntax tree:

``` sml
    type tvar = int
    local val freshSource = ref 0 in
    fun fresh () : tvar =
        !freshSource before freshSource := !freshSource + 1
    end


    datatype monotype = TBool
                      | TArr of monotype * monotype
                      | TVar of tvar
    datatype polytype = PolyType of int list * monotype

    datatype exp = True
                 | False
                 | Var of int
                 | App of exp * exp
                 | Let of exp * exp
                 | Fn of exp
                 | If of exp * exp * exp
```

First we have type variables which are globally unique integers. To
give us a method for actually producing them we have `fresh` which
uses a ref-cell to never return the same result twice. From there we
have mono-types. These are normal ML types without any
polymorphism. There are type variables, booleans, and
functions. Polytypes are just monotypes with an extra `forall` at the
front. This is where we get polymorphism from. A polytype binds a
number of type variables, stored in this representation as an int
list.

Finally, we have expressions. Aside form the normal constants, we have
variables, lambdas, applications, and if. The way we represent
variables here is with DeBruijn variables. A variable is a number that
tells you how many binders are between it and where it was bound. For
example, `const` would be written `Fn (Fn (Var 1))` in this
representation.

With this in mind we define some helpful utility functions. When type
checking, we have a context full of information. The two facts we know
are

``` sml
    datatype info = PolyTypeVar of polytype
                  | MonoTypeVar of monotype

    type context = info list
```

Where the ith element of a context indicates the piece of information
we know about the ith DeBruijn variable. We'll also need to
substitute a type variable for a type. We also want to be able to find
out all the free variables in a type.

``` sml
    fun subst ty' var ty =
        case ty of
            TVar var' => if var = var' then ty' else TVar var'
          | TArr (l, r) => TArr (subst ty' var l, subst ty' var r)
          | TBool => TBool

    fun freeVars t =
        case t of
            TVar v => [v]
          | TArr (l, r) => freeVars l @ freeVars r
          | TBool => []
```

Both of these functions just recurse over types and do some work at
the variable case. Note that `freeVars` can contain duplicates, this
turns out not to be important in all cases except one:
`generalizeMonoType`. The basic idea is that given a monotype with a
bunch of unification variables and a surrounding context, figure out
which variables can be bound up in a polymorphic type. If they don't
appear in the surrounding context, we generalize them by binding them
in a new poly type's forall spot.

``` sml
    fun dedup [] = []
      | dedup (x :: xs) =
        if List.exists (fn y => x = y) xs
        then dedup xs
        else x :: dedup xs

    fun generalizeMonoType ctx ty =
        let fun notMem xs x = List.all (fn y => x <> y) xs
            fun free (MonoTypeVar m) = freeVars m
              | free (PolyTypeVar (PolyType (bs, m))) =
                List.filter (notMem bs) (freeVars m)

            val ctxVars = List.concat (List.map free ctx)
            val polyVars = List.filter (notMem ctxVars) (freeVars ty)
        in PolyType (dedup polyVars, ty) end
```

Here the bulk of the code is deciding whether or not a variable is
free in the surrounding context using `free`. It looks at a piece of
info to determine what variables occur in it. We then accumulate all of
these variables into `cxtVars` and use this list to decide what to
generalize.

Next we need to take a polytype to a monotype. This is the
specialization of a polymorphic type that we love and use when we use
`map` on a function from `int -> double`. This works by taking each
bound variable and replacing it with a fresh unification
variables. This is nicely handled by folds!

``` sml
    fun mintNewMonoType (PolyType (ls, ty)) =
        foldl (fn (v, t) => subst (TVar (fresh ())) v t) ty ls
```

Last but not least, we have a function to take a context and a
variable and give us a monotype which corresponds to it. This may
produce a new monotype if we think the variable has a polytype.

``` sml
    exception UnboundVar of int
    fun lookupVar var ctx =
        case List.nth (ctx, var) handle Subscript => raise UnboundVar var of
            PolyTypeVar pty => mintNewMonoType pty
          | MonoTypeVar mty => mty
```

For the sake of nice error messages, we also throw `UnboundVar`
instead of just subscript in the error case. Now that we've gone
through all of the utility functions, on to unification!

## Unification

A large part of this program is basically "I'll give you a list of
constraints and you give me the solution". The program to solve these
proceeds by pattern matching on the constraints.

In the empty case, we have no constraints so we give back the empty
solution.

``` sml
    fun unify [] = []
```

In the next case we actually have to look at what constraint we're
trying to solve.

``` sml
      | unify (c :: constrs) =
        case c of
```

If we're lucky, we're just trying to unify `TBool` with `TBool`, this
does nothing since these types have no variables and are equal. In
this case we just recurse.

``` sml
       (TBool, TBool) => unify constrs
```

If we've got two function types, we just constrain their domains and
ranges to be the same and continue on unifying things.

``` sml
     | (TArr (l, r), TArr (l', r')) => unify ((l, l') :: (r, r') :: constrs)
```

Now we have to deal with finding a variable. We definitely want to
avoid adding `(TVar v, TVar v)` to our solution, so we'll have a
special case for trying to unify two variables.

``` sml
     | (TVar i, TVar j) =>
       if i = j
       then unify constrs
       else addSol i (TVar j) (unify (substConstrs (TVar j) i constrs))
```

This is our first time actually adding something to our solution so
there's several new elements here. The first is this function
`addSol`. It's defined as

``` sml
    fun addSol v ty sol = (v, applySol sol ty) :: sol
```

So in order to make sure our solution is internally consistent it's
important that whenever we add a type to our solution we first apply
the solution to it. This ensures that we can substitute a variable in
our solution for its corresponding type and not worry about whether we
need to do something further. Additionally, whenever we add a new
binding we substitute for it in the constraints we have left to ensure
we never have a solution which is just inconsistent. This prevents us
from unifying `v ~ TBool` and `v ~ TArr(TBool, TBool)` in the same
solution! The actual code for doing this is that
`substConstr (TVar j) i constrs` bit.

The next case is the general case for unifying a variable with some
type. It looks very similar to this one.

``` sml
     | ((TVar i, ty) | (ty, TVar i)) =>
       if occursIn i ty
       then raise UnificationError c
       else addSol i ty (unify (substConstrs ty i constrs))
```

Here we have the critical `occursIn` check. This checks to see if a
variable appears in a type and prevents us from making erroneous
unifications like `TVar a ~ TArr (TVar a, TVar a)`. This occurs check
is actually very easy to implement

``` sml
    fun occursIn v ty = List.exists (fn v' => v = v') (freeVars ty)
```

Finally we have one last case: the failure case. This is the catch-all
case for if we try to unify two things that are obviously
incompatible.

``` sml
     | _ => raise UnificationError c
```

All together, that code was

``` sml
    fun applySol sol ty =
        foldl (fn ((v, ty), ty') => subst ty v ty') ty sol
    fun applySolCxt sol cxt =
        let fun applyInfo i =
                case i of
                    PolyTypeVar (PolyType (bs, m)) =>
                    PolyTypeVar (PolyType (bs, (applySol sol m)))
                  | MonoTypeVar m => MonoTypeVar (applySol sol m)
        in map applyInfo cxt end

    fun addSol v ty sol = (v, applySol sol ty) :: sol

    fun occursIn v ty = List.exists (fn v' => v = v') (freeVars ty)

    fun unify ([] : constr list) : sol = []
      | unify (c :: constrs) =
        case c of
            (TBool, TBool) => unify constrs
          | (TVar i, TVar j) =>
            if i = j
            then unify constrs
            else addSol i (TVar j) (unify (substConstrs (TVar j) i constrs))
          | ((TVar i, ty) | (ty, TVar i)) =>
            if occursIn i ty
            then raise UnificationError c
            else addSol i ty (unify (substConstrs ty i constrs))
          | (TArr (l, r), TArr (l', r')) =>
            unify ((l, l') :: (r, r') :: constrs)
          | _ => raise UnificationError c
```

## Constraint Generation

The other half of this algorithm is the constraint generation part. We
generate constraints and use `unify` to turn them into solutions. One
critical portion of this.
