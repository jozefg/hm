## An Explanation of This Code

OK, so now that I've wowed you with my awesome code, let's talk about
what's going on. Type inference breaks down into essentially 2
components

 1. Constraint Generation
 2. Unification

We inspect the program we're trying to infer a type for and generate a
bunch of statements (constraints) which are of the form

> This type is equal to this type

These types have "unification variables" in them. These **aren't
normal ML type variables**. They're generated by the compiler, for the
compiler, and will eventually be filled in with either

 1. A rigid polymorphic variable
 2. A normal concrete type

For example, if we're looking at the expression

``` sml
   f a
```

We first just say that `f : 'f` where `'f` is one of those unification
variables I mentioned. Next we say that `a : 'a`. Since we're apply
`f` to `a` we can generate the constraints that

    'f ~ 'x -> 'y
    'a ~ 'x

We then unify these constraints to produce `f : 'a -> 'x` and `a :
'a`. We'd then using the surrounding constraints to produce more
information about what exactly `'a` and `'x` might be.

Now onto some specifics

## Constraint Generation

## Unification
